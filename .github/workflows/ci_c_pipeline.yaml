name: Deploy Microservices

on:
  workflow_call:
    inputs:
      service_name:
        required: true
        type: string
      aggregator_service:
        required: false
        type: boolean
    secrets:
      GCP_SA_KEY:
        required: true
      GCP_PROJECT_ID:
        required: true
      GKE_CLUSTER_NAME:
        required: true
      GKE_REGION:
        required: true
      DATABASE_USER:
        required: true
      DATABASE_PASSWORD:
        required: true
      DATABASE_ENDPOINT:
        required: true
      DATABASE_NAME:
        required: true
      REDSHIFT_USER:
        required: false
      REDSHIFT_PASSWORD:
        required: false
      REDSHIFT_HOST:
        required: false
      REDSHIFT_DB:
        required: false

jobs:
  build_image:
    runs-on: ubuntu-latest
    env:
      GCP_PROJECT_ID: ${{ secrets.GCP_PROJECT_ID }}
      SERVICE: ${{ inputs.service_name }}
    steps:
      - name: Checkout Code
        uses: actions/checkout@v3

      - name: Set up Google Cloud SDK
        uses: google-github-actions/setup-gcloud@v1
        with:
          project_id: ${{ secrets.GCP_PROJECT_ID }}

      - name: Authenticate with GCP
        uses: google-github-actions/auth@v1
        with:
          credentials_json: ${{ secrets.GCP_SA_KEY }}

      - name: Configure gcloud project
        run: gcloud config set project ${{ secrets.GCP_PROJECT_ID }}

      - name: Install gke-gcloud-auth-plugin
        run: |
          gcloud components install gke-gcloud-auth-plugin
          export USE_GKE_GCLOUD_AUTH_PLUGIN=True

      - name: Authenticate with GKE
        run: |
          gcloud container clusters get-credentials ${{ secrets.GKE_CLUSTER_NAME }} --region ${{ secrets.GKE_REGION }}

      - name: Create Kubernetes Secret for DATABASE_URL
        run: |
          kubectl create secret generic ${SERVICE}-db-secret \
            --from-literal=DATABASE_URL=postgresql://${{ secrets.DATABASE_USER }}:${{ secrets.DATABASE_PASSWORD }}@${{ secrets.DATABASE_ENDPOINT }}:5432/${{ secrets.DATABASE_NAME }} || echo "Secret already exists"

      - name: Create Redshift Secret for REDSHIFT_URL
        if: ${{ inputs.aggregator_service == 'true' }}
        run: |
          kubectl create secret generic ${SERVICE}-redshift-secret \
          --from-literal=REDSHIFT_URL=postgresql://${{ secrets.REDSHIFT_USER }}:${{ secrets.REDSHIFT_PASSWORD }}@${{ secrets.REDSHIFT_HOST }}:5439/${{ secrets.REDSHIFT_DB }} || echo "Secret already exists"

      - name: Authenticate Docker with Artifact Registry
        run: gcloud auth configure-docker ${{ secrets.GKE_REGION }}-docker.pkg.dev

      - name: Build & Push Docker Image to GCP
        run: |
          docker build -t ${{ secrets.GKE_REGION }}-docker.pkg.dev/${{ secrets.GCP_PROJECT_ID }}/moon-insurance/${SERVICE}:latest .
          docker push ${{ secrets.GKE_REGION }}-docker.pkg.dev/${{ secrets.GCP_PROJECT_ID }}/moon-insurance/${SERVICE}:latest

  blue_green_deploy:
    if: ${{ inputs.aggregator_service != 'true' }}
    runs-on: ubuntu-latest
    needs: build_image
    env:
      SERVICE: ${{ inputs.service_name }}

    steps:
      - name: Get Current Live Version (blue/green)
        id: get-version
        run: |
          CURRENT=$(kubectl get service ${SERVICE} -o jsonpath='{.spec.selector.version}' || echo "none")
          echo "CURRENT_VERSION=${CURRENT}" >> $GITHUB_ENV

      - name: Define Idle Version
        run: |
          if [[ "${{ env.CURRENT_VERSION }}" == "blue" ]]; then
            echo "IDLE_VERSION=green" >> $GITHUB_ENV
          elif [[ "${{ env.CURRENT_VERSION }}" == "green" ]]; then
            echo "IDLE_VERSION=blue" >> $GITHUB_ENV
          else
            echo "IDLE_VERSION=blue" >> $GITHUB_ENV  # Default to blue if no version found
          fi

      - name: Deploy Idle Version
        run: |
          kubectl apply -f k8s/deployment-${IDLE_VERSION}.yaml

      - name: Wait for Idle Deployment to be Ready (Optional Rollback)
        run: |
          if kubectl get deployment ${SERVICE}-${IDLE_VERSION} > /dev/null 2>&1; then
            if ! kubectl rollout status deployment/${SERVICE}-${IDLE_VERSION} --timeout=120s; then
              echo "Rollout failed for ${SERVICE}-${IDLE_VERSION}. Keeping ${CURRENT_VERSION} live."
              exit 1
            fi
          else
            echo "First time deployment detected, skipping rollout status check."
          fi

      - name: Create or Patch Service to Point to Idle Version
        run: |
          if kubectl get service ${SERVICE} > /dev/null 2>&1; then
            echo "Patching service ${SERVICE} to point to ${IDLE_VERSION}"
            kubectl patch service ${SERVICE} -p "{\"spec\":{\"selector\":{\"app\":\"${SERVICE}\",\"version\":\"${IDLE_VERSION}\"}}}"
          else
            echo " Creating service ${SERVICE} for the first time"
            kubectl apply -f k8s/service.yaml
            kubectl patch service ${SERVICE} -p "{\"spec\":{\"selector\":{\"app\":\"${SERVICE}\",\"version\":\"${IDLE_VERSION}\"}}}"
          fi

      - name: Success Message
        run: echo "Successfully switched ${SERVICE} to ${IDLE_VERSION}"

  deploy_aggregator:
    if: ${{ inputs.aggregator_service == 'true' }}
    runs-on: ubuntu-latest
    needs: build_image
    env:
      SERVICE: ${{ inputs.service_name }}

    steps:
      - name: Deploy Aggregator Service
        run: |
          kubectl apply -f k8s/aggregator_cron_job.yaml

      - name: Success Message
        run: echo "Successfully deployed ${SERVICE}"
